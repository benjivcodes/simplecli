#!/usr/bin/env python3
# Grab credentials from Thycotic instance and use those in an ssh session.

import requests
import pexpect
import argparse
import getpass
import json
import time
import sys
import os

class LoginError(Exception):
    """raised when login is wrong"""
    pass

class SecretNotFound(Exception):
    """raised when no secret is found with given name"""
    pass

class SecretCheckInError(Exception):
    """raised when secret checkin cannot occur"""
    pass

class LauncherNotFound(Exception):
    """raised when launcher cannot be found"""
    pass

class ProxyError(Exception):
    """raised when unable to get Proxy Info"""
    pass

def getToken( baseUrl, username, password ):
    authUrl = baseUrl + '/oauth2/token'
    creds = {
        'username' : username,
        'password' : password,
        'grant_type' : 'password'
    }
    headers = { 'Content-Type' : 'application/x-www-form-urlencoded' }
    try:
        resp = requests.post( authUrl, data=creds, headers=headers )
    except requests.exceptions.ConnectionError as e:
        raise LoginError( 'Unable to establish connection to ' + baseUrl )
    except Exception as e:
        raise LoginError( 'Unhandled exception : ' + str(e) )
    if resp.status_code != 200:
        raise LoginError( 'Wrong Login or Password' )
    data = resp.json()
    return data['access_token']

def isSecretCheckedIn( baseUrl, token, secretId ):
    authHeader = { 'Authorization' : 'Bearer ' + token }
    secretUrl = baseUrl + '/api/v1/secrets/' + str( secretId )
    resp = requests.get( secretUrl, headers=authHeader )
    data = resp.json()
    return data['checkedOut']

def checkInSecret( baseUrl, token, secretId ):
    authHeader = { 'Authorization' : 'Bearer ' + token }
    checkInUrl = baseUrl + '/api/v1/secrets/' + str( secretId ) + '/check-in'
    body = {
        'forceCheckIn' : True
    }
    resp = requests.post( checkInUrl, data=body, headers=authHeader )
    if resp.status_code != 200:
        raise SecretCheckInError('Unable to Check-In Secret')
    return True

def getSecretId( baseUrl, token, secretName ):
    authHeader = { 'Authorization' : 'Bearer ' + token }
    findUrl = baseUrl + '/api/v1/secrets?filter.includeRestricted=true&filter.searchText=' + secretName
    resp = requests.get( findUrl, headers=authHeader )
    data = resp.json()
    for r in data['records']:
        if r['name'].lower() == secretName:
            return r['id']
    raise SecretNotFound('Unable to find secret named : ' + secretName )

def getSSHLauncherId( baseUrl, token ):
    authHeader = { 'Authorization' : 'Bearer ' + token }
    launcherUrl = baseUrl + "/api/v1/launchers"
    resp = requests.get( launcherUrl, headers=authHeader )
    data = resp.json()
    for i in data['records']:
        if i['name'] == 'PuTTY':
            return i['id']
    raise LauncherNotFound('Unable to find PuTTY launcher, contact the PIM team to validate configuration')

def getSSHProxyInfo( baseUrl, token, machineName, secretId ):
    launcherId = getSSHLauncherId( baseUrl, token )
    sshProxyUrl = baseUrl + "/api/v1/secrets/sshproxy"
    authHeader = { 'Authorization' : 'Bearer ' + token }
    body = {
        'launcherType' : launcherId,
        'machine' : machineName,
        'secretId' : secretId
    }
    resp = requests.post( sshProxyUrl, data=body, headers=authHeader )
    if resp.status_code != 200:
        raise ProxyError('Unable to get Proxy Information to start SSH')
    data = resp.json()
    return data['host'], data['username'], data['password']


termSize = os.get_terminal_size()
termColumnCount = termSize.columns
termLineCount = termSize.lines


parser = argparse.ArgumentParser()

parser.add_argument('-t', '--thycoticUrl',
                    required=True,
                    action='store',
                    help='Thycotic Server Url')

parser.add_argument('-u', '--loginUser',
                    required=True,
                    action='store',
                    help='Your Thycotic Login User')

parser.add_argument('-s', '--thycoticLoginSecret',
                    required=True,
                    action='store',
                    help='Your Thycotic Login Secret (the user you check out')

parser.add_argument('-d', '--dest',
                    required=True,
                    action='store',
                    help='destination server')

parser.add_argument('-p', '--password',
                    required=False,
                    action='store',
                    help='password as argument')


args = parser.parse_args()

username = args.loginUser
password = args.password
baseUrl = args.thycoticUrl
machineName = args.dest
secretName = args.thycoticLoginSecret

try:
    token = getToken( baseUrl, username, password )
except Exception as e:
    print( str(e) )
    sys.exit(1)

try:
    secretId = getSecretId( baseUrl, token, secretName )
except Exception as e:
    print( str(e) )
    sys.exit(1)

if not isSecretCheckedIn( baseUrl, token, secretId ):
    try:
        checkInSecret( baseUrl, token, secretId )
    except Exception as e:
        print( str(e) )
        sys.exit(1)

try:
    sshServer, sshLogin, sshPassword = getSSHProxyInfo( baseUrl, token, machineName, secretId )
except Exception as e:
    print( str(e) )
    sys.exit(1)

expectedLoginLine = sshLogin + "'s password:"
sshCommand = 'ssh -o ServerAliveInterval=60' + sshLogin + '@' + sshServer
authIssue = "Are you sure you want to continue connecting (yes/no/[fingerprint])?"

p = pexpect.spawn(sshCommand)

i = p.expect([expectedLoginLine,authIssue,pexpect.EOF])

if i == 1:
    p.sendline("yes")
    p.sendline("\r")
    i = p.expect([expectedLoginLine,pexpect.EOF])

p.setwinsize(termLineCount, termColumnCount)
p.sendline(sshPassword)
p.sendline("\r")
p.interact()