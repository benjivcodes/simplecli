#!/usr/bin/env bash
# Common functions for BaSH Profile Configuration
# This should be sources from the environment configuration, e.g. .bash_profile

export BASH_SILENCE_DEPRECATION_WARNING=1
export CLIHOME="/usr/local/lib/simplecli"
export LOGIN_TRACKER=".login"

PATH=/usr/local/opt/openssl/bin:${PATH}
PATH=/usr/local/opt/curl/bin:${PATH}
PATH=/usr/local/opt/coreutils/libexec/gnubin:${PATH}
PATH=/usr/local/opt/gnu-getopt/bin:${PATH}
PATH=/usr/local/opt/go/libexec/bin:${PATH}
PATH=/usr/local/opt/grep/libexec/gnubin:${PATH}
PATH=/usr/local/opt/gnu-getopt/bin:${PATH}
PATH=/usr/local/opt/gnu-sed/libexec/gnubin:${PATH}
PATH=/usr/local/opt/ruby/bin:${PATH}
PATH=${PATH}:/usr/local/bin:/usr/local/sbin:/bin:/sbin:/usr/bin:/usr/sbin
export PATH

# Setup some input pre-processing on less.
export LESSOPEN="|lesspipe.sh %s"

# Load some completion scripts
if [ "${SHELL}" = "/bin/bash" ] && [ -e "/usr/local/etc/bash_completion" ]
then
  source "/usr/local/etc/bash_completion"
fi

# If available, source integration support for iterm2
if [ "${SHELL}" = "/bin/bash" ] && [ -e "${HOME}/.iterm2_shell_integration.bash" ]
then
  source "${HOME}/.iterm2_shell_integration.bash"
fi

# Let's make Homebrew a litte less chatty
export HOMEBREW_USE_GCC=1
export HOMEBREW_VERBOSE=1

# Are we on macOS
function darwinonly(){
  if [ ! "$(uname -s)" == "Darwin" ]; then
    echo -e "\n This is macOS specific function, sorry.\n"
    exit 1
  fi
}

# Simple file sort
function sf(){
  sort -u -o $1 $1
}

# Smarter ssh-agent handling
function sshagent_findsockets(){
  find /tmp -uid $(id -u) -type s -name agent.\* 2>/dev/null
}

function sshagent_testsocket(){
  if [ ! -x "$(which ssh-add)" ]; then
    echo "ssh-add is not available; agent testing aborted"
    return 1
  fi

  if [ X"$1" != X ] ; then
    export SSH_AUTH_SOCK=$1
  fi

  if [ X"${SSH_AUTH_SOCK}" = X ]; then
    return 2
  fi

  if [ -S ${SSH_AUTH_SOCK} ]; then
    ssh-add -l > /dev/null
    if [ $? = 2 ] ; then
      echo "Socket ${SSH_AUTH_SOCK} is dead!  Deleting!"
      rm -f ${SSH_AUTH_SOCK}
      return 4
    else
      echo "Found ssh-agent ${SSH_AUTH_SOCK}"
      return 0
    fi
  else
    echo "${SSH_AUTH_SOCK} is not a socket!"
    return 3
  fi
}

function sshagent_init(){
  # ssh agent sockets can be attached to a ssh daemon process or an
  # ssh-agent process.

  AGENTFOUND=0

  # Attempt to find and use the ssh-agent in the current environment
  if sshagent_testsocket ; then AGENTFOUND=1 ; fi

  # If there is no agent in the environment, search /tmp for
  # possible agents to reuse before starting a fresh ssh-agent
  # process.
  if [ ${AGENTFOUND} = 0 ]; then
    for agentsocket in $(sshagent_findsockets) ; do
      if [ ${AGENTFOUND} != 0 ] ; then break ; fi
      if sshagent_testsocket $agentsocket ; then AGENTFOUND=1 ; fi
    done
  fi

  # If at this point we still haven't located an agent, it's time to
  # start a new one
  if [ ${AGENTFOUND} = 0 ]; then
    eval $(ssh-agent)
  fi

  # Clean up
  unset AGENTFOUND
  unset agentsocket

  # Finally, show what keys are currently in the agent
  ssh-add -l
}

# Update slacktee
function update_slacktee(){
  pushd . >/dev/null || exit 1
  cd /tmp || exit1
  rm -f "slacktee.sh"
  curl -s https://api.github.com/repos/coursehero/slacktee/releases/latest \
    | jq '.zipball_url' \
    | xargs wget -qic  -A ".zip" -O temp.zip && unzip -q -j -o -u "temp.zip" "*slacktee.sh"
  mv "slacktee.sh" "/usr/local//bin/slacktee"
  rm -f "temp.zip"
  popd >/dev/null || exit 1
}

# Inject new locations into the first position in $PATH
function pathmunge(){
  if ! echo "${PATH}" | grep -E -q "(^|:)$1($|:)"
  then
    PATH="$1":"${PATH}"
  fi
}

# Inject new locations into the first position in $MANPATH
function manpathmunge(){
  if ! echo "${MANPATH}" | grep -E -q "(^|:)$1($|:)"
  then
    MANPATH="$1":"${MANPATH}"
  fi
}

# Run a basic BaSH lint with shellcheck on a script
function checkscript(){
  /usr/local/bin/shellcheck -s bash "$1"
}

# A date function with standarized formatting
function timestamp(){
  date '+%Y-%m-%d %H:%M:%S'
}

# Replace dashes with underscores
function rdashes(){
  for i in *-*; do
    j="${i//-/_}"
    mv "$i" "$j"
  done
}

# Replace spaces with underscores
function rspaces(){
  for i in *" "*; do
    j="${i// /_}"
    mv "$i" "$j"
  done
}

# Create a password encryped DMG from a folder on MacOS
function dmgcrypt(){
  darwinonly
  local vol src

  if [ -z "$1" ]; then
    echo -e "Volume name:"
    read -r vol
  else
    vol="$1"
  fi

  if [ -z "$2" ]; then
    echo -e "\nSource folder:"
    read -r src
  else
    src="$2"
  fi

  echo -e "\n"
  hdiutil create "${vol}".dmg -ov -volname "${vol}" \
    -fs HFS+ -encryption AES-256 -stdinpass -srcfolder "${src}"
}

# Create an unencryped DMG from a folder on MacOS
function dmg(){
  darwinonly
  local vol src

  if [ -z "$1" ]; then
    echo -e "Volume name:"
    read -r vol
  else
    vol="$1"
  fi

  if [ -z "$2" ]; then
    echo -e "\nSource folder:"
    read -r src
  else
    src="$2"
  fi

  echo -e "\n"
  hdiutil create "${vol}".dmg -ov -volname "${vol}" -fs HFS+ -srcfolder "${src}"
}

# Read from file so that you can iterate over each line
function readfrom(){
  while read -r line; do echo "$line"; done < "$1"
}

# Attempt to download Youtube video and make mp3 file from the audio
function yt2mp3(){
  [ ! -e /usr/local/bin/youtube-dl ] && brew install youtube-dl
  [ ! -e /usr/local/bin/ffmpeg ] && brew install ffmpeg
  if [ -z "$1" ]; then
    echo -e "\n!!! Youtube Link Please..."
    read -r ytlink
    youtube-dl "${ytlink}" -q -x --audio-format mp3 -o "/tmp/%(title)s.%(ext)s"
  else
    ytlink="$1"
    youtube-dl "${ytlink}" -q -x --audio-format mp3 -o "/tmp/%(title)s.%(ext)s"
  fi
}

# Extract pubkey from pem file
function sshpem2pub(){
  ssh-keygen -y -f "$1"
}

# Simple color test
function colortest(){
  echo -e "\033[0mCOLOR_NC (No color)"
  echo -e "\033[1;37mCOLOR_WHITE\t\033[0;30mCOLOR_BLACK"
  echo -e "\033[0;34mCOLOR_BLUE\t\033[1;34mCOLOR_LIGHT_BLUE"
  echo -e "\033[0;32mCOLOR_GREEN\t\033[1;32mCOLOR_LIGHT_GREEN"
  echo -e "\033[0;36mCOLOR_CYAN\t\033[1;36mCOLOR_LIGHT_CYAN"
  echo -e "\033[0;31mCOLOR_RED\t\033[1;31mCOLOR_LIGHT_RED"
  echo -e "\033[0;35mCOLOR_PURPLE\t\033[1;35mCOLOR_LIGHT_PURPLE"
  echo -e "\033[0;33mCOLOR_YELLOW\t\033[1;33mCOLOR_LIGHT_YELLOW"
  echo -e "\033[1;30mCOLOR_GRAY\t\033[0;37mCOLOR_LIGHT_GRAY"
}

# Single use invocation of ClamScan
function scanthis(){
  darwinonly
  [ ! -e "/usr/local/bin/freshclam" ] && brew install clamav > /dev/null 2>&1
  echo -e "\n Updating virus definitions..."
  /usr/local/bin/freshclam --quiet
  echo -e "\n Begining scan of target: $1"
  clamscan --infected --recursive=yes --scan-mail=yes --max-filesize=2000M "$1"
}

# Remove the hidden file attribute
function unhide(){
  darwinonly
  sudo chflags nohidden "$1"
}

# Let's have some help working with relative paths; this should resolve the current location
# of the script it's run from (yes, it's self referencing) even it's a symlink! This
# could be much simpler when you don't care about symmlinks:
# DIR=$(dirname "${BASH_SOURCE[0]}")
function whereami(){
  SOURCE="${BASH_SOURCE[0]}"
  while [ -h "${SOURCE}" ]; do
    DIR="$(cd -P "$(dirname "${SOURCE}")" && pwd)"
    SOURCE="$(readlink "${SOURCE}")"
    [[ ${SOURCE} != /* ]] && SOURCE="$DIR/${SOURCE}"
  done
  DIR="$(cd -P "$(dirname "${SOURCE}")" && pwd)"
}

function _git_prompt(){
  local git_status="$(git status -unormal 2>&1)"
  if ! [[ ${git_status} =~ Not\ a\ git\ repo ]]; then
   if [[ ${git_status} =~ nothing\ to\ commit ]]; then
      local ansi=$IGreen
    elif [[ ${git_status} =~ nothing\ added\ to\ commit\ but\ untracked\ files\ present ]]; then
      local ansi=$IYellow
    else
      local ansi=$IRed
    fi
    if [[ ${git_status} =~ On\ branch\ ([^[:space:]]+) ]]; then
      branch=${BASH_REMATCH[1]}
      test "$branch" != master || branch='master'
    else
      # Detached HEAD.  (branch=HEAD is a faster alternative.)
      branch="$(git describe --all --contains --abbrev=4 HEAD 2> /dev/null || echo HEAD)"
    fi
    echo -n "\[$ansi\]""(""$branch"")""\[$Color_Off\]"
  fi
}

function _prompt_command(){
  PS1="\[$IRed\][\h]\[$IRed\][\[$Blue\]\u\[$IPurple\]::\W\[$IRed\]]\[$IGreen\]\$ \[$Color_Off\]"
}

# How long is the cert valid?
function cert-valid-until(){
  /usr/local/opt/openssl/bin/openssl x509 -dates -noout -in $1
}

function appify(){
 darwinonly
 APPNAME=${2:-$(basename "$1" ".sh")}
 dir="${APPNAME}.app/Contents/MacOS"

 if [ -a "${APPNAME}.app" ]; then
   echo "$PWD/${APPNAME}.app already exists :("
   exit 1
 fi

 mkdir -p "${DIR}"
 cp "$1" "${DIR}/${APPNAME}"
 chmod +x "${DIR}/${APPNAME}"

 echo "${PWD}/${APPNAME}.app"
}

# Set some aliases
alias ...='reset'
alias cp='cp'
alias e='vimr'
alias ls='ls -FG --color=auto'
alias rm='rm -i'
alias sudo='sudo -H'
alias vi='/usr/bin/vim -X'
alias vim='/usr/bin/vim -X'
alias grep='grep --color'

# Turn the Vagrant gui off
export VAGRANT_GUI="false"

# Disable Homebrew Analytics
export HOMEBREW_NO_ANALYTICS=1

# Set the default editor.
EDITOR="/usr/bin/vim"
export EDITOR VISUAL="${EDITOR}" SVN_EDITOR="${EDITOR}"

# Set some behavior reguarding history.
export HISTFILE="${HOME}/.bash_history"
export HISTSIZE=100000
export HISTCONTROL=ignoreboth
export HISTTIMEFORMAT="%F %T "
if [ "${SHELL}" = "/bin/bash" ]
then
  shopt -s histappend
fi

# Ensure no core files by default.
ulimit -S -c 0

# Set some basic colors
export LSCOLORS=gxfxcxdxbxegedabagacad

# Try to get lines to wrap correctly.
if [ "${SHELL}" = "/bin/bash" ]
then
  shopt -s checkwinsize
fi

# Set a reasonable umask
umask 022

# Enable SuDo tab completion
if [ "${SHELL}" = "/bin/bash" ]
then
  complete -cf sudo
fi

# Set shellcheck options
export SHELLCHECK_OPTS="-x -e SC2145 -e SC2155 -e SC2154 -e SC2086 -e SC2046 -e SC2003 -e SC1090 -e SC1117 -e SC1090 -e SC1091 -e SC2059 -e SC2034 -e SC2002 -e SC2005 -e SC1001 -e SC2004 -e SC1091"

# Go settings
if [ "$(uname -s)" = "Darwin" ]; then
    export GOROOT="/usr/local/opt/go/libexec"
    export GOPATH="${GOROOT}/bin/go"
else
    export GOPATH="/usr/share/go/"
fi

### Begin BaSH colors ###
if [ "${SHELL}" = "/bin/bash" ]
then
  # Reset
  Color_Off='\e[0m' # Text Reset

  # Regular Colors
  Black='\e[0;30m'  # Black
  Red='\e[0;31m'    # Red
  Green='\e[0;32m'  # Green
  Yellow='\e[0;33m' # Yellow
  Blue='\e[0;34m'   # Blue
  Purple='\e[0;35m' # Purple
  Cyan='\e[0;36m'   # Cyan
  White='\e[0;37m'  # White

  # Bold
  BBlack='\e[1;30m'  # Black
  BRed='\e[1;31m'    # Red
  BGreen='\e[1;32m'  # Green
  BYellow='\e[1;33m' # Yellow
  BBlue='\e[1;34m'   # Blue
  BPurple='\e[1;35m' # Purple
  BCyan='\e[1;36m'   # Cyan
  BWhite='\e[1;37m'  # White

  # Underline
  UBlack='\e[4;30m'  # Black
  URed='\e[4;31m'    # Red
  UGreen='\e[4;32m'  # Green
  UYellow='\e[4;33m' # Yellow
  UBlue='\e[4;34m'   # Blue
  UPurple='\e[4;35m' # Purple
  UCyan='\e[4;36m'   # Cyan
  UWhite='\e[4;37m'  # White

  # Background
  On_Black='\e[40m'  # Black
  On_Red='\e[41m'    # Red
  On_Green='\e[42m'  # Green
  On_Yellow='\e[43m' # Yellow
  On_Blue='\e[44m'   # Blue
  On_Purple='\e[45m' # Purple
  On_Cyan='\e[46m'   # Cyan
  On_White='\e[47m'  # White

  # High Intensty
  IBlack='\e[0;90m'  # Black
  IRed='\033[0;91m'  # Red
  IGreen='\e[0;92m'  # Green
  IYellow='\e[0;93m' # Yellow
  IBlue='\e[0;94m'   # Blue
  IPurple='\e[0;95m' # Purple
  ICyan='\e[0;96m'   # Cyan
  IWhite='\e[0;97m'  # White

  # Bold High Intensty
  BIBlack='\e[1;90m'  # Black
  BIRed='\e[1;91m'    # Red
  BIGreen='\e[1;92m'  # Green
  BIYellow='\e[1;93m' # Yellow
  BIBlue='\e[1;94m'   # Blue
  BIPurple='\e[1;95m' # Purple
  BICyan='\e[1;96m'   # Cyan
  BIWhite='\e[1;97m'  # White

  # High Intensty backgrounds
  On_IBlack='\e[0;100m'  # Black
  On_IRed='\e[0;101m'    # Red
  On_IGreen='\e[0;102m'  # Green
  On_IYellow='\e[0;103m' # Yellow
  On_IBlue='\e[0;104m'   # Blue
  On_IPurple='\e[10;95m' # Purple
  On_ICyan='\e[0;106m'   # Cyan
  On_IWhite='\e[0;107m'  # White

  export CLICOLOR=1
fi
### End BaSH Colors ###
